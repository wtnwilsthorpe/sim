<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flexible Alkane Chain Phase Change Simulator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; /* Dark background */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }
        #simulator-container {
            width: 100%;
            max-width: 1200px;
            background: #ffffff;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            padding: 20px;
        }
        .canvas-container {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            background-color: #f9fafb;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            /* CRITICAL: Fixed Panel Height ratio */
            position: relative;
            padding-top: calc(800 / 300 * 100%); 
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            width: 100%;
            height: 100%;
        }
        /* Phase colors remain the same for consistency */
        .state-solid { background-color: #fef2f2; }
        .state-liquid { background-color: #fefce8; }
        .state-gas { background-color: #ecfdf5; }
        .state-text-solid { color: #b91c1c; }
        .state-text-liquid { color: #ca8a04; }
        .state-text-gas { color: #047857; }
    </style>
</head>
<body>

    <div id="simulator-container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">
            Flexible Alkane Carbon Chain Phase Simulator
        </h1>
        <p class="text-center text-sm text-gray-600 mb-6">
            Notice how chain **flexibility (wobble)** increases as temperature rises and the substance enters the liquid and gas phases.
        </p>

        <!-- Temperature Slider Control -->
        <div class="mb-8 p-4 bg-gray-100 rounded-lg shadow-inner">
            <div class="flex items-center justify-between mb-4">
                <label for="tempRange" class="font-bold text-lg text-blue-700">
                    Temperature ($\text{T}$): 
                </label>
                <div class="flex space-x-4 items-center">
                    <span id="tempValue" class="text-xl font-mono bg-blue-100 p-2 rounded-md">$-250^\circ\text{C}$</span>
                    <button id="runButton" onclick="toggleRunStop()" 
                            class="px-4 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition duration-150">
                        Run
                    </button>
                </div>
            </div>

            <input type="range" id="tempRange" min="-250" max="200" step="1" value="-250" 
                   class="w-full h-3 bg-blue-200 rounded-lg appearance-none cursor-pointer range-lg mt-2">
            <div class="flex justify-between text-sm text-gray-500 mt-1">
                <span>$-250^\circ\text{C}$ (Cold Start)</span>
                <span>$200^\circ\text{C}$ (Hot End)</span>
            </div>

            <!-- Checkbox for IMFs -->
            <div class="mt-4 pt-4 border-t border-gray-300">
                <label for="showImfs" class="flex items-center space-x-2 font-bold text-base text-gray-700 cursor-pointer">
                    <input type="checkbox" id="showImfs" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <span>Show Intermolecular Forces (LDFs)</span>
                </label>
                <p class="text-xs text-gray-500 mt-1 ml-7">
                    Line thickness represents force strength; strength increases with chain length.
                </p>
            </div>
        </div>

        <!-- Alkane Panels (Grid Layout - Forced 4 columns) -->
        <div id="panels-grid" class="grid grid-cols-2 sm:grid-cols-4 gap-4">
            <!-- Panels generated by JavaScript -->
        </div>
    </div>

    <script>
        // --- PHYSICAL CONSTANTS AND CONFIGURATION ---

        const ALKANE_DATA = [
            // numCarbons determines chain structure. sizeScale is derived from numCarbons
            { id: 'M', name: 'Methane', symbol: 'CH\u2084', numCarbons: 1, mp: -182, bp: -161, sizeScale: 1.0, color: '#f97316' }, 
            { id: 'P', name: 'Propane', symbol: 'C\u2083H\u2088', numCarbons: 3, mp: -187, bp: -42, sizeScale: 3.0, color: '#10b981' }, 
            { id: 'Pe', name: 'Pentane', symbol: 'C\u2085H\u2081\u2082', numCarbons: 5, mp: -130, bp: 36, sizeScale: 5.0, color: '#3b82f6' }, 
            { id: 'H', name: 'Heptane', symbol: 'C\u2087H\u2081\u2086', numCarbons: 7, mp: -91, bp: 98, sizeScale: 7.0, color: '#8b5cf6' }  
        ];

        const BASE_C_RADIUS = 3; 
        const C_VISUAL_MULTIPLIER = 2.0; 
        const C_BOND_LENGTH = 12; // Distance between centers of adjacent carbons
        const MAX_WOBBLE_DISPLACEMENT = 3.5; // Max displacement of end carbons from the straight axis
        
        const NUM_PARTICLES = 25; 
        const VIBRATION_SCALE = 1.5;
        const IMF_CUTOFF_DISTANCE = 80; 

        // --- GLOBAL STATE ---
        let showIMFs = false; 
        let isRunning = false;
        let tempIntervalId = null;
        const ROTATION_DAMPING = 0.99; 

        
        // --- PARTICLE SIMULATION CLASS (Alkane Molecule - Chain) ---

        class Particle {
            constructor(x, y, data) {
                this.originalX = x;
                this.originalY = y;
                this.x = x;
                this.y = y;
                this.data = data;

                this.C_radius = BASE_C_RADIUS * C_VISUAL_MULTIPLIER; 
                this.numCarbons = data.numCarbons;
                
                // Effective radius accounts for the entire length of the chain + padding
                const halfChainLength = (this.numCarbons > 1) ? (this.numCarbons - 1) / 2 * C_BOND_LENGTH : 0;
                this.effectiveRadius = halfChainLength + this.C_radius; 
                
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                
                this.angle = Math.random() * Math.PI * 2;
                this.angularVelocity = (Math.random() - 0.5) * 0.02;

                this.color = data.color;
            }
            
            // Calculates the coordinates of all carbon atoms, including the wobble effect
            getCarbonCoordinates(magnitude) {
                const coords = [];
                const halfIndex = (this.numCarbons - 1) / 2;
                
                // Calculate perpendicular vector (90 degrees to the chain angle)
                const perpAngle = this.angle + Math.PI / 2;
                const cosPerp = Math.cos(perpAngle);
                const sinPerp = Math.sin(perpAngle);
                
                const wobbleStrength = magnitude * 0.15; // Scales 0 to ~4.5 max
                
                for (let i = 0; i < this.numCarbons; i++) {
                    // 1. Straight chain position (r_k is distance from CM)
                    const r_k = (i - halfIndex) * C_BOND_LENGTH;
                    
                    // 2. Base position (straight chain)
                    let x_k = this.x + r_k * Math.cos(this.angle);
                    let y_k = this.y + r_k * Math.sin(this.angle);
                    
                    // 3. Add Wobble (perpendicular displacement)
                    if (this.numCarbons > 1) { // Only wobble chains, not methane
                        // Displacement scale: 0 at center, 1 at ends
                        const displacementScale = Math.abs(i - halfIndex) / halfIndex; 
                        
                        // Wobble uses a combination of sine functions based on time for fluid motion
                        const wobbleNoise = Math.sin(performance.now() * 0.01 + i * 2) * Math.sin(performance.now() * 0.005 + i * 1.5);
                        
                        const displacement = MAX_WOBBLE_DISPLACEMENT * displacementScale * wobbleNoise * wobbleStrength;

                        x_k += displacement * cosPerp;
                        y_k += displacement * sinPerp;
                    }

                    coords.push({ x: x_k, y: y_k });
                }
                return coords;
            }


            update(canvas, state, magnitude) {
                switch (state) {
                    case 'Solid':
                        // Constrained vibration
                        this.x = this.originalX + (Math.sin(performance.now() * 0.02) * magnitude * (Math.random() - 0.5));
                        this.y = this.originalY + (Math.cos(performance.now() * 0.02) * magnitude * (Math.random() - 0.5));
                        // Rotation oscillation
                        this.angle += 0.005 * magnitude * Math.sin(performance.now() * 0.05); 
                        break;

                    case 'Liquid':
                        // Translational and rotational movement with bounds
                        this.x += this.vx;
                        this.y += this.vy;
                        
                        this.angle += this.angularVelocity;
                        this.angularVelocity *= ROTATION_DAMPING; 
                        this.angularVelocity += (Math.random() - 0.5) * 0.0005; 

                        if (this.x - this.effectiveRadius < 0 || this.x + this.effectiveRadius > canvas.width) this.vx *= -1;
                        if (this.y - this.effectiveRadius < 0 || this.y + this.effectiveRadius > canvas.height) this.vy *= -1;
                        
                        // Random nudges for Brownian motion
                        this.vx += (Math.random() - 0.5) * 0.01;
                        this.vy += (Math.random() - 0.5) * 0.01;

                        break;

                    case 'Gas':
                        // Fast, free, randomized translational and rotational movement (wraps around)
                        this.x += this.vx * 3; 
                        this.y += this.vy * 3;
                        
                        this.angle += this.angularVelocity * 2;
                        this.angularVelocity += (Math.random() - 0.5) * 0.005; 

                        if (this.x + this.effectiveRadius < 0) this.x = canvas.width + this.effectiveRadius;
                        if (this.x - this.effectiveRadius > canvas.width) this.x = -this.effectiveRadius;
                        if (this.y + this.effectiveRadius < 0) this.y = canvas.height + this.effectiveRadius;
                        if (this.y - this.effectiveRadius > canvas.width) this.y = -this.effectiveRadius;
                        break;
                }
            }

            draw(ctx, magnitude) {
                // Get coordinates including the temperature-dependent wobble
                const coords = this.getCarbonCoordinates(magnitude); 

                if (coords.length > 1) {
                    // 1. Draw Bonds (backbone)
                    ctx.strokeStyle = this.color + 'A0'; // Slightly darker, more opaque bond
                    ctx.lineWidth = 4; 
                    ctx.beginPath();
                    ctx.moveTo(coords[0].x, coords[0].y);
                    for (let i = 1; i < coords.length; i++) {
                        ctx.lineTo(coords[i].x, coords[i].y);
                    }
                    ctx.stroke();
                }

                // 2. Draw Carbon Atoms (circles)
                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#374151'; // Dark gray outline
                ctx.lineWidth = 1.5;

                coords.forEach(c => {
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, this.C_radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();
                });
            }
        }

        // --- IMF DRAWING FUNCTION ---

        function drawIMFs(canvas, ctx, particles, data) {
            // R_MIN for IMF drawing should be the actual minimum distance between molecule centers
            const R_MIN_DRAW = particles.length > 0 ? particles[0].effectiveRadius * 2.1 : 30; 
            
            // POLARIZABILITY_SCALE: Linear with sizeScale (number of carbons), ensuring strength visualization
            const POLARIZABILITY_SCALE = data.sizeScale * 0.015; 

            for (let i = 0; i < particles.length; i++) {
                const p1 = particles[i];
                for (let j = i + 1; j < particles.length; j++) {
                    const p2 = particles[j];

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const r = Math.sqrt(dx * dx + dy * dy);

                    if (r > R_MIN_DRAW && r < IMF_CUTOFF_DISTANCE) {
                        const r_inv_power = 1 / (r * r * r * r); // Force falloff
                        const strength = POLARIZABILITY_SCALE * r_inv_power;
                        
                        // Normalization based on strength at R_MIN_DRAW
                        const MAX_STRENGTH_AT_R_MIN = POLARIZABILITY_SCALE * (1 / (R_MIN_DRAW * R_MIN_DRAW * R_MIN_DRAW * R_MIN_DRAW));
                        const normalizedStrength = Math.min(1, strength / MAX_STRENGTH_AT_R_MIN); 
                        
                        // Line width: Base thickness raised to 2.0 to ensure visibility
                        let lineWidth = 2.0 + normalizedStrength * 4.0; 

                        ctx.beginPath();
                        ctx.setLineDash([5, 5]); 
                        // Blue with varying opacity and thickness
                        ctx.strokeStyle = `rgba(59, 130, 246, ${0.6 + normalizedStrength * 0.4})`; 
                        ctx.lineWidth = lineWidth;
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                        ctx.closePath();
                        ctx.setLineDash([]); 
                    }
                }
            }
        }

        // --- AUTOMATION AND UI CONTROL (Same as before) ---

        const simulators = {};
        const tempRange = document.getElementById('tempRange');
        const tempValueDisplay = document.getElementById('tempValue');
        const runButton = document.getElementById('runButton');

        function updateTemperature(newValue) {
            tempRange.value = newValue;
            tempValueDisplay.textContent = `${newValue}°C`;
        }
        
        function toggleRunStop() {
            if (isRunning) {
                clearInterval(tempIntervalId);
                tempIntervalId = null;
                runButton.textContent = 'Run';
                runButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                runButton.classList.add('bg-green-600', 'hover:bg-green-700');
                isRunning = false;
            } else {
                if (parseInt(tempRange.value) >= parseInt(tempRange.max)) {
                    updateTemperature(tempRange.min); 
                }
                
                runButton.textContent = 'Stop';
                runButton.classList.remove('bg-green-600', 'hover:bg-green-700');
                runButton.classList.add('bg-red-600', 'hover:bg-red-700');
                isRunning = true;

                tempIntervalId = setInterval(() => {
                    let currentTemp = parseInt(tempRange.value);
                    const maxTemp = parseInt(tempRange.max);

                    if (currentTemp < maxTemp) {
                        currentTemp += 1; 
                        updateTemperature(currentTemp);
                    } else {
                        toggleRunStop(); 
                    }
                }, 50); 
            }
        }
        
        // --- SIMULATOR MANAGER ---

        // Creates the HTML structure for one element panel
        function createPanelHTML(data) {
            const panelsGrid = document.getElementById('panels-grid');
            const container = document.createElement('div');
            container.className = 'canvas-container flex flex-col items-center p-3';
            
            const header = document.createElement('h2');
            header.className = 'text-2xl font-semibold mb-2 text-center text-gray-700';
            header.textContent = data.symbol + ' (' + data.name + ')';
            container.appendChild(header);

            const canvas = document.createElement('canvas');
            canvas.id = `canvas-${data.id}`;
            canvas.width = 300; 
            canvas.height = 800; // Fixed height
            container.appendChild(canvas);

            const info = document.createElement('div');
            info.className = 'text-center mt-2 w-full';
            info.innerHTML = `
                <p class="text-xs text-gray-500">MP: ${data.mp}°C | BP: ${data.bp}°C</p>
                <p id="state-label-${data.id}" class="text-lg font-bold mt-1 p-1 rounded-md state-text-solid">State: Solid</p>
            `;
            container.appendChild(info);

            panelsGrid.appendChild(container);
            return canvas;
        }

        // Initializes particles for a specific canvas in a lattice structure
        function initParticles(canvas, data) {
            const particles = [];
            
            // Calculate size and spacing based on the alkane's size scale
            const halfChainLength = (data.numCarbons > 1) ? (data.numCarbons - 1) / 2 * C_BOND_LENGTH : 0;
            const effectiveRadius = halfChainLength + (BASE_C_RADIUS * C_VISUAL_MULTIPLIER); 
            
            // Spacing must account for the molecule size
            const SPACING = effectiveRadius * 2.8; 
            
            const cols = Math.floor(canvas.width / SPACING);
            const rows = Math.floor(canvas.height / SPACING); 
            
            // Calculate starting position to center the lattice
            const startX = (canvas.width - (cols * SPACING)) / 2 + SPACING / 2;
            const startY = (canvas.height - (rows * SPACING)) / 2 + SPACING / 2;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (particles.length >= NUM_PARTICLES) break;
                    
                    const x = startX + c * SPACING;
                    const y = startY + r * SPACING;
                    
                    // Push Particle instance
                    particles.push(new Particle(x, y, data));
                }
            }
            return particles;
        }

        // Main animation loop for one element
        function animateElement(canvas, ctx, data) {
            const particles = simulators[data.id].particles;
            const stateLabel = document.getElementById(`state-label-${data.id}`);
            const tempC = parseFloat(tempRange.value);

            let currentState;
            let magnitude = 0; 

            // Determine Phase based on MP/BP
            if (tempC < data.mp) {
                currentState = 'Solid';
                // Magnitude scales vibration (0 to 1) for Solid
                magnitude = Math.max(0, (tempC - tempRange.min) / (data.mp - tempRange.min));
            } else if (tempC < data.bp) {
                currentState = 'Liquid';
                // Magnitude scales movement/flexibility (1 to 2) for Liquid
                magnitude = 1 + Math.max(0, (tempC - data.mp) / (data.bp - data.mp));
            } else {
                currentState = 'Gas';
                // Magnitude scales movement/flexibility (2 to 3) for Gas
                magnitude = 2 + Math.max(0, (tempC - data.bp) / (tempRange.max - data.bp)); 
            }
            
            stateLabel.textContent = `State: ${currentState}`;
            stateLabel.className = `text-lg font-bold mt-1 p-1 rounded-md state-text-${currentState.toLowerCase()}`;
            
            canvas.parentNode.classList.remove('state-solid', 'state-liquid', 'state-gas');
            canvas.parentNode.classList.add(`state-${currentState.toLowerCase()}`);


            // 1. Clear Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. Draw IMFs (Visible only if checked AND not in the Gas phase)
            if (showIMFs && currentState !== 'Gas') {
                drawIMFs(canvas, ctx, particles, data);
            }

            // 3. Update and Draw Particles
            particles.forEach(p => {
                p.update(canvas, currentState, magnitude);
                // Pass magnitude to draw for wobble calculation
                p.draw(ctx, magnitude); 
            });

            // 4. Request next frame
            requestAnimationFrame(() => animateElement(canvas, ctx, data));
        }

        // Setup function called on load
        function setupSimulators() {
            ALKANE_DATA.forEach(data => {
                const canvas = createPanelHTML(data);
                const ctx = canvas.getContext('2d');
                
                canvas.width = 300;
                canvas.height = 800; 

                const particles = initParticles(canvas, data);
                
                simulators[data.id] = { canvas, ctx, particles, data };
                
                // Start the animation loop for this element
                animateElement(canvas, ctx, data);
            });

            // Set up slider and checkbox event listeners
            tempRange.addEventListener('input', () => {
                updateTemperature(tempRange.value);
                // Stop automatic run if the user manually adjusts the slider
                if (isRunning) {
                    toggleRunStop();
                }
            });

            const showImfsCheckbox = document.getElementById('showImfs');
            showImfsCheckbox.addEventListener('change', () => {
                showIMFs = showImfsCheckbox.checked;
            });
            
            // Initial update
            updateTemperature(tempRange.value);
        }

        window.onload = function () {
            setupSimulators();
        }
    </script>
</body>
</html>