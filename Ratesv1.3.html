<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GCSE Rates of Reaction - Projector Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root { --bg: #020617; --text: #f8fafc; --panel: rgba(15, 23, 42, 0.95); --border: #1e293b; --card: rgba(30, 41, 59, 0.5); }
        .light-mode { --bg: #f8fafc; --text: #0f172a; --panel: #ffffff; --border: #e2e8f0; --card: #f1f5f9; }
        
        body { background-color: var(--bg); color: var(--text); overflow: hidden; font-family: 'Inter', sans-serif; transition: background 0.3s; }
        .control-panel { background: var(--panel); border-right: 1px solid var(--border); z-index: 10; }
        .metric-card { background: var(--card); border: 1px solid var(--border); }
        
        input[type="range"] { height: 6px; -webkit-appearance: none; background: #334155; border-radius: 3px; outline: none; width: 100%; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: #38bdf8; border-radius: 50%; cursor: pointer; border: 2px solid white; }
        .btn-active { background-color: #0284c7 !important; border-color: #38bdf8 !important; color: white !important; }
        #sim-container { border: 3px solid var(--border); border-radius: 12px; background: rgba(0,0,0,0.05); transition: width 0.3s ease; }
    </style>
</head>
<body class="flex h-screen">

    <aside class="control-panel w-80 p-5 flex flex-col gap-4 overflow-y-auto shrink-0 shadow-2xl">
        <div class="flex justify-between items-start">
            <div>
                <h1 class="text-xl font-black leading-none uppercase">Reaction Pro</h1>
                <p class="text-[10px] text-sky-500 font-bold tracking-widest uppercase mt-1">Collision Theory Model</p>
            </div>
            <button id="theme-toggle" class="p-2 rounded-full bg-slate-200 dark:bg-slate-800 hover:scale-110 transition">ðŸŒ“</button>
        </div>

        <div class="flex gap-2">
            <button id="btn-reset" class="flex-1 bg-red-500/10 text-red-500 border border-red-500/20 hover:bg-red-500 hover:text-white py-2 rounded text-xs font-bold transition uppercase">Reset Totals</button>
            <button id="btn-play" class="flex-1 bg-sky-600 text-white hover:bg-sky-500 py-2 rounded text-xs font-bold transition uppercase">Start Sim</button>
        </div>

        <div class="space-y-3 py-2 border-y border-slate-400/20">
            <div class="space-y-1">
                <div class="flex justify-between text-[10px] font-bold uppercase text-slate-400">
                    <span>A (Blue)</span> <span id="label-a">30</span>
                </div>
                <input type="range" id="input-a" min="0" max="80" value="30">
            </div>
            <div class="space-y-1">
                <div class="flex justify-between text-[10px] font-bold uppercase text-slate-400">
                    <span>B (Red)</span> <span id="label-b">50</span>
                </div>
                <input type="range" id="input-b" min="0" max="150" value="50">
            </div>
            <div class="space-y-1">
                <div class="flex justify-between text-[10px] font-bold uppercase text-slate-400">
                    <span>Solvent (Grey)</span> <span id="label-w">20</span>
                </div>
                <input type="range" id="input-w" min="0" max="100" value="20">
            </div>
        </div>

        <div class="space-y-4">
            <div class="space-y-1">
                <div class="flex justify-between text-[10px] font-bold uppercase text-slate-400">
                    <span>Kinetic Energy (Temp)</span>
                </div>
                <input type="range" id="input-temp" min="1" max="15" value="5">
            </div>

            <div class="space-y-1">
                <div class="flex justify-between text-[10px] font-bold uppercase text-slate-400">
                    <span>Activation Energy</span>
                </div>
                <input type="range" id="input-ae" min="0" max="100" value="40">
            </div>

            <div class="space-y-1">
                <div class="flex justify-between text-[10px] font-bold uppercase text-slate-400">
                    <span>Vessel Pressure (Volume)</span>
                </div>
                <input type="range" id="input-width" min="40" max="100" value="100">
            </div>

            <div class="space-y-1">
                <label class="text-[10px] font-bold uppercase text-slate-400">Surface Area (Red B)</label>
                <div class="grid grid-cols-2 gap-1" id="sa-btns">
                    <button data-sa="lump" class="sa-btn text-[9px] py-2 bg-slate-800 rounded font-bold border border-transparent">LARGE LUMP</button>
                    <button data-sa="medium" class="sa-btn text-[9px] py-2 bg-slate-800 rounded font-bold border border-transparent">MEDIUM BLOCKS</button>
                    <button data-sa="small" class="sa-btn text-[9px] py-2 bg-slate-800 rounded font-bold border border-transparent">SMALL BLOCKS</button>
                    <button data-sa="gas" class="sa-btn text-[9px] py-2 bg-slate-800 rounded font-bold border border-transparent btn-active">FREE GAS</button>
                </div>
            </div>
        </div>

        <div class="mt-auto space-y-4">
            <div class="p-3 rounded-lg border border-dashed border-slate-400/30 space-y-2">
                <div class="flex justify-between items-center">
                    <span class="text-[10px] font-bold uppercase">Projector Zoom</span>
                    <span id="label-scale" class="font-mono text-xs">1.0x</span>
                </div>
                <input type="range" id="input-scale" min="0.8" max="2.5" step="0.1" value="1.0">
            </div>

            <div class="grid grid-cols-2 gap-2">
                <div class="metric-card p-3 rounded text-center">
                    <div class="text-[9px] font-bold uppercase opacity-60">Collisions</div>
                    <div id="m-total" class="text-2xl font-black tracking-tighter">0</div>
                </div>
                <div class="metric-card p-3 rounded text-center border-green-500/30">
                    <div class="text-[9px] font-bold uppercase text-green-500">Success</div>
                    <div id="m-success" class="text-2xl font-black text-green-500 tracking-tighter">0</div>
                </div>
            </div>
        </div>
    </aside>

    <main class="flex-grow flex items-center justify-center p-8 bg-black/5 dark:bg-black/20">
        <div id="sim-container" class="relative overflow-hidden shadow-2xl bg-white/5">
            <canvas id="canvas"></canvas>
            <div class="absolute bottom-4 left-4 flex gap-4 text-[10px] font-bold uppercase opacity-40 pointer-events-none">
                <div class="flex items-center gap-2"><div class="w-3 h-3 rounded-full bg-blue-500"></div> A</div>
                <div class="flex items-center gap-2"><div class="w-3 h-3 rounded-full bg-red-500"></div> B</div>
                <div class="flex items-center gap-2"><div class="w-3 h-3 rounded-full bg-slate-400"></div> Solvent</div>
                <div class="flex items-center gap-2"><div class="w-3 h-3 rounded-full bg-green-500"></div> Product</div>
            </div>
        </div>
    </main>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const simContainer = document.getElementById('sim-container');

        let state = {
            playing: false,
            particles: [],
            blocks: [],
            metrics: { total: 0, success: 0 },
            sa: 'gas',
            vesselWidth: 100,
            scale: 1.0,
            theme: 'dark'
        };

        class Block {
            constructor(x, y, particleCount, spacing) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 1.5;
                this.vy = (Math.random() - 0.5) * 1.5;
                this.rotation = Math.random() * Math.PI;
                this.rv = (Math.random() - 0.5) * 0.02;
                this.particles = [];
                
                // Calculate grid dimensions for requested count
                let cols = Math.ceil(Math.sqrt(particleCount));
                let rows = Math.ceil(particleCount / cols);
                
                let count = 0;
                for(let r=0; r<rows; r++) {
                    for(let c=0; c<cols; c++) {
                        if (count < particleCount) {
                            this.particles.push({ 
                                ox: (c - (cols-1)/2) * spacing, 
                                oy: (r - (rows-1)/2) * spacing, 
                                active: true 
                            });
                            count++;
                        }
                    }
                }
            }

            update() {
                if (!state.playing) return;
                this.x += this.vx; this.y += this.vy; this.rotation += this.rv;
                const r = 30 * state.scale;
                if (this.x < r || this.x > canvas.width - r) this.vx *= -1;
                if (this.y < r || this.y > canvas.height - r) this.vy *= -1;
            }
        }

        class Particle {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                this.setRandomVelocity();
                this.angle = Math.random() * Math.PI * 2;
                this.rv = (Math.random() - 0.5) * 0.1;
                this.partner = null;
            }

            setRandomVelocity() {
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
            }

            update(temp) {
                if (!state.playing) return;
                const speedMult = temp * 0.35;
                if (this.type === 'P' && this.partner) {
                    this.x += this.vx * speedMult;
                    this.y += this.vy * speedMult;
                    this.angle += this.rv;
                    this.partner.x = this.x + Math.cos(this.angle) * (14 * state.scale);
                    this.partner.y = this.y + Math.sin(this.angle) * (14 * state.scale);
                    this.bounceWalls(this);
                    this.bounceWalls(this.partner);
                } else {
                    this.x += this.vx * speedMult;
                    this.y += this.vy * speedMult;
                    this.bounceWalls(this);
                }
            }

            bounceWalls(p) {
                const r = 8 * state.scale;
                if (p.x < r) { p.x = r; p.vx *= -1; }
                if (p.x > canvas.width - r) { p.x = canvas.width - r; p.vx *= -1; }
                if (p.y < r) { p.y = r; p.vy *= -1; }
                if (p.y > canvas.height - r) { p.y = canvas.height - r; p.vy *= -1; }
            }
        }

        function init() {
            state.particles = [];
            state.blocks = [];
            
            const countA = parseInt(document.getElementById('input-a').value);
            const countB = parseInt(document.getElementById('input-b').value);
            const countW = parseInt(document.getElementById('input-w').value);

            const containerWidth = (state.vesselWidth / 100) * (window.innerWidth - 320);
            canvas.width = Math.max(300, containerWidth);
            canvas.height = window.innerHeight - 100;
            simContainer.style.width = canvas.width + 'px';

            for(let i=0; i<countA; i++) state.particles.push(new Particle(Math.random()*canvas.width, Math.random()*canvas.height, 'A'));
            for(let i=0; i<countW; i++) state.particles.push(new Particle(Math.random()*canvas.width, Math.random()*canvas.height, 'W'));

            if (state.sa === 'gas') {
                for(let i=0; i<countB; i++) state.particles.push(new Particle(Math.random()*canvas.width, Math.random()*canvas.height, 'B'));
            } else {
                let numLumps = { lump: 1, medium: 4, small: 8 }[state.sa];
                const spacing = 14 * state.scale;
                const perLump = Math.floor(countB / numLumps);
                const remainder = countB % numLumps;

                for(let i=0; i<numLumps; i++) {
                    const blockCount = perLump + (i === 0 ? remainder : 0);
                    if (blockCount <= 0) continue;
                    
                    const block = new Block(
                        Math.random()*(canvas.width-100)+50, 
                        Math.random()*(canvas.height-100)+50, 
                        blockCount, spacing
                    );
                    state.blocks.push(block);
                }
            }
        }

        function resolveCircleCollision(p1, p2) {
            const dx = p1.x - p2.x, dy = p1.y - p2.y;
            const dist = Math.sqrt(dx*dx+dy*dy);
            const r = 8 * state.scale;
            if (dist < r * 2) {
                const angle = Math.atan2(dy, dx);
                const sin = Math.sin(angle), cos = Math.cos(angle);
                const overlap = (r * 2) - dist;
                p1.x += cos * overlap/2; p1.y += sin * overlap/2;
                p2.x -= cos * overlap/2; p2.y -= sin * overlap/2;
                const v1 = { x: p1.vx * cos + p1.vy * sin, y: p1.vy * cos - p1.vx * sin };
                const v2 = { x: p2.vx * cos + p2.vy * sin, y: p2.vy * cos - p2.vx * sin };
                p1.vx = v2.x * cos - v1.y * sin; p1.vy = v2.x * sin + v1.y * cos;
                p2.vx = v1.x * cos - v2.y * sin; p2.vy = v1.x * sin + v2.y * cos;
                return true;
            }
            return false;
        }

        function handleCollisions() {
            const temp = parseInt(document.getElementById('input-temp').value);
            const ae = parseInt(document.getElementById('input-ae').value);
            const radius = 8 * state.scale;

            for (let i=0; i < state.particles.length; i++) {
                let p1 = state.particles[i];
                if (p1.type !== 'A') continue;

                for (let j=0; j < state.particles.length; j++) {
                    let p2 = state.particles[j];
                    if (p2.type !== 'B') continue;

                    const dx = p1.x - p2.x, dy = p1.y - p2.y, d = Math.sqrt(dx*dx+dy*dy);
                    if (d < radius * 2) {
                        state.metrics.total++;
                        const collisionEnergy = Math.random() * temp * 10;
                        if (collisionEnergy > ae) {
                            state.metrics.success++;
                            p1.type = 'P'; p1.partner = p2; p2.type = 'P_CHILD';
                        } else {
                            resolveCircleCollision(p1, p2);
                        }
                    }
                }

                for (let block of state.blocks) {
                    for (let bp of block.particles) {
                        if (!bp.active) continue;
                        const cos = Math.cos(block.rotation), sin = Math.sin(block.rotation);
                        const wx = block.x + bp.ox * cos - bp.oy * sin;
                        const wy = block.y + bp.ox * sin + bp.oy * cos;
                        
                        const dx = p1.x - wx, dy = p1.y - wy, d = Math.sqrt(dx*dx+dy*dy);
                        if (d < radius * 2) {
                            state.metrics.total++;
                            const collisionEnergy = Math.random() * temp * 10;
                            if (collisionEnergy > ae) {
                                state.metrics.success++;
                                bp.active = false;
                                p1.type = 'P';
                                p1.partner = new Particle(wx, wy, 'B');
                            } else {
                                // Bounce off block surface
                                p1.vx *= -1; p1.vy *= -1;
                            }
                        }
                    }
                }
            }
            
            for (let i=0; i < state.particles.length; i++) {
                for (let j=i+1; j < state.particles.length; j++) {
                    const p1 = state.particles[i], p2 = state.particles[j];
                    if (p1.type === 'P_CHILD' || p2.type === 'P_CHILD') continue;
                    resolveCircleCollision(p1, p2);
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const r = 8 * state.scale;

            state.blocks.forEach(b => {
                b.update();
                const cos = Math.cos(b.rotation), sin = Math.sin(b.rotation);
                b.particles.forEach(p => {
                    if (!p.active) return;
                    const wx = b.x + p.ox * cos - p.oy * sin;
                    const wy = b.y + p.ox * sin + p.oy * cos;
                    ctx.fillStyle = '#ef4444';
                    ctx.beginPath(); ctx.arc(wx, wy, r, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = state.theme === 'dark' ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
                    ctx.stroke();
                });
            });

            state.particles.forEach(p => {
                if (p.type === 'P_CHILD') return;
                ctx.beginPath();
                if (p.type === 'A') ctx.fillStyle = '#3b82f6';
                else if (p.type === 'B') ctx.fillStyle = '#ef4444';
                else if (p.type === 'W') ctx.fillStyle = '#94a3b8'; // Grey Solvent
                
                if (p.type === 'P') {
                    ctx.fillStyle = '#22c55e';
                    ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(p.partner.x, p.partner.y, r, 0, Math.PI*2);
                } else {
                    ctx.arc(p.x, p.y, r, 0, Math.PI*2);
                }
                ctx.fill();
            });
        }

        function loop() {
            if (state.playing) {
                const temp = parseInt(document.getElementById('input-temp').value);
                state.particles.forEach(p => p.update(temp));
                handleCollisions();
                document.getElementById('m-total').innerText = state.metrics.total;
                document.getElementById('m-success').innerText = state.metrics.success;
            }
            draw();
            requestAnimationFrame(loop);
        }

        document.getElementById('btn-play').onclick = (e) => {
            state.playing = !state.playing;
            e.target.innerText = state.playing ? 'Pause Sim' : 'Start Sim';
            e.target.className = state.playing ? "flex-1 bg-amber-500 text-white py-2 rounded text-xs font-bold transition uppercase" : "flex-1 bg-sky-600 text-white hover:bg-sky-500 py-2 rounded text-xs font-bold transition uppercase";
        };

        document.getElementById('btn-reset').onclick = () => {
            state.metrics = { total: 0, success: 0 };
            document.getElementById('m-total').innerText = "0";
            document.getElementById('m-success').innerText = "0";
            init();
        };

        document.getElementById('theme-toggle').onclick = () => {
            document.body.classList.toggle('light-mode');
            state.theme = state.theme === 'dark' ? 'light' : 'dark';
        };

        document.getElementById('input-scale').oninput = (e) => {
            state.scale = parseFloat(e.target.value);
            document.getElementById('label-scale').innerText = state.scale.toFixed(1) + 'x';
            init();
        };

        document.getElementById('sa-btns').onclick = (e) => {
            if (!e.target.dataset.sa) return;
            state.sa = e.target.dataset.sa;
            document.querySelectorAll('.sa-btn').forEach(b => b.classList.remove('btn-active'));
            e.target.classList.add('btn-active');
            init();
        };

        ['a', 'b', 'w', 'width'].forEach(id => {
            document.getElementById(`input-${id}`).oninput = (e) => {
                if (id === 'width') state.vesselWidth = e.target.value;
                if (document.getElementById(`label-${id}`)) document.getElementById(`label-${id}`).innerText = e.target.value;
                init();
            };
        });

        window.onresize = init;
        init();
        loop();
    </script>
</body>
</html>