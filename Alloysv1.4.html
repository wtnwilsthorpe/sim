<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metallic Lattice Distortion</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #020617; color: #f8fafc; font-family: system-ui, sans-serif; overflow: hidden; touch-action: none; }
        canvas { border-radius: 12px; background: #010409; cursor: grab; }
        canvas:active { cursor: grabbing; }
        .panel { background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .active-mode { border-color: #3b82f6; background: rgba(59, 130, 246, 0.2); }
    </style>
</head>
<body class="flex flex-col h-screen p-4">
    <div class="max-w-[1200px] mx-auto w-full flex flex-col h-full gap-4">
        
        <header class="flex flex-wrap justify-between items-center p-4 panel rounded-xl gap-4">
            <div>
                <h1 class="text-xl font-bold text-blue-400">Alloy Lattice Distortion</h1>
                <p class="text-slate-400 text-xs italic">Observe how irregular atoms disrupt the "slip planes"</p>
            </div>
            <div class="flex gap-4 items-center">
                <button onclick="resetLattice()" class="px-4 py-2 rounded-lg bg-slate-800 hover:bg-slate-700 text-[10px] font-bold">
                    RESET LATTICE
                </button>
            </div>
        </header>

        <div class="flex flex-col lg:flex-row gap-4 flex-grow overflow-hidden">
            <div class="relative flex-grow rounded-xl overflow-hidden border border-slate-800">
                <canvas id="simCanvas"></canvas>
                <div id="feedback" class="absolute top-4 left-4 bg-black/60 p-2 rounded text-[10px] text-blue-300 font-mono transition-opacity opacity-0">
                    LATTICE PINNED BY IMPURITY
                </div>
            </div>

            <aside class="lg:w-72 panel p-5 rounded-xl flex flex-col gap-6">
                <section>
                    <h2 class="text-[10px] font-bold text-slate-500 uppercase tracking-widest mb-3">Material Structure</h2>
                    <div class="space-y-2">
                        <button onclick="setMode('pure')" id="m-pure" class="w-full text-left p-3 rounded border border-slate-700 text-xs active-mode">
                            <span class="font-bold block text-yellow-400">Pure Metal (Gold/Cu)</span>
                            <span class="opacity-60 text-[10px]">Identical sizes allow for perfect "slip planes". Malleable.</span>
                        </button>
                        <button onclick="setMode('alloy')" id="m-alloy" class="w-full text-left p-3 rounded border border-slate-700 text-xs">
                            <span class="font-bold block text-slate-300">Alloy (Bronze/Steel)</span>
                            <span class="opacity-60 text-[10px]">Different sized atoms distort the rows, pinning them in place. Hard.</span>
                        </button>
                    </div>
                </section>

                <div class="p-4 bg-blue-900/20 rounded-lg border border-blue-500/20 text-[11px] leading-relaxed text-blue-100">
                    <p class="mb-2"><strong>The Science:</strong></p>
                    <p>In a pure metal, layers slide over each other smoothly because the potential energy landscape is uniform.</p>
                    <p class="mt-2">In an alloy, the "mismatch" in atom size creates local stress fields. This <strong>distorts</strong> the lattice, making it much harder for layers to slide past one another.</p>
                </div>
            </aside>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const feedback = document.getElementById('feedback');
        
        let width, height;
        let layers = [];
        let mode = 'pure';
        let activeLayer = null;
        let dragStartX = 0;
        let startOffsetX = 0;

        const ATOM_R = 25;
        const SPACING = 52;
        const ROW_HEIGHT = 46; // Tight packing

        class Atom {
            constructor(relX, type = 'metal') {
                this.relX = relX;
                this.type = type;
                this.r = type === 'metal' ? ATOM_R : ATOM_R * 1.35;
                this.color = type === 'metal' ? '#facc15' : '#94a3b8';
                this.label = type === 'metal' ? '+' : 'Sn';
            }
        }

        class Layer {
            constructor(y, index) {
                this.y = y;
                this.baseY = y;
                this.index = index;
                this.offsetX = 0;
                this.targetX = 0;
                this.atoms = [];
                this.distortionY = 0;
            }

            init() {
                this.atoms = [];
                const count = Math.ceil(width / SPACING) + 6;
                const rowOffset = (this.index % 2) * (SPACING / 2);
                
                for (let i = -3; i < count; i++) {
                    let type = 'metal';
                    if (mode === 'alloy' && Math.random() > 0.88) {
                        type = 'impurity';
                    }
                    this.atoms.push(new Atom(i * SPACING + rowOffset, type));
                }
            }

            update() {
                // Smooth interpolation to target
                let slideSpeed = mode === 'pure' ? 0.2 : 0.08;
                this.offsetX += (this.targetX - this.offsetX) * slideSpeed;

                // Lattice Distortion Logic
                // If there's an impurity in the layer above or below, this layer's Y position is pushed
                this.distortionY = 0;
                if (mode === 'alloy') {
                    // Check neighbors for distortion
                    const neighbors = [layers[this.index - 1], layers[this.index + 1]].filter(Boolean);
                    neighbors.forEach(n => {
                        n.atoms.forEach(a => {
                            const ax = a.relX + n.offsetX;
                            if (a.type === 'impurity') {
                                // Find distance from this layer's atoms to that impurity
                                this.atoms.forEach(thisA => {
                                    const tx = thisA.relX + this.offsetX;
                                    const dx = Math.abs(tx - ax);
                                    if (dx < SPACING * 0.8) {
                                        this.distortionY += (this.index < n.index ? -8 : 8) * (1 - dx/(SPACING*0.8));
                                    }
                                });
                            }
                        });
                    });
                }
            }

            draw() {
                this.atoms.forEach(atom => {
                    const x = atom.relX + this.offsetX;
                    const y = this.baseY + this.distortionY;

                    // Glow for impurities
                    if (atom.type === 'impurity') {
                        const grad = ctx.createRadialGradient(x, y, 0, x, y, atom.r * 1.5);
                        grad.addColorStop(0, 'rgba(148, 163, 184, 0.2)');
                        grad.addColorStop(1, 'rgba(148, 163, 184, 0)');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(x, y, atom.r * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.beginPath();
                    ctx.arc(x, y, atom.r, 0, Math.PI * 2);
                    ctx.fillStyle = atom.color;
                    ctx.fill();
                    
                    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Ion charge
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.font = `bold ${atom.r * 0.6}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(atom.label, x, y);
                });
            }
        }

        function initLattice() {
            layers = [];
            const layerCount = 7;
            const startY = (height / 2) - (layerCount * ROW_HEIGHT / 2) + ROW_HEIGHT/2;
            
            for (let i = 0; i < layerCount; i++) {
                const l = new Layer(startY + (i * ROW_HEIGHT), i);
                l.init();
                layers.push(l);
            }
        }

        function setMode(m) {
            mode = m;
            document.getElementById('m-pure').classList.toggle('active-mode', m === 'pure');
            document.getElementById('m-alloy').classList.toggle('active-mode', m === 'alloy');
            initLattice();
        }

        function resetLattice() {
            layers.forEach(l => l.targetX = 0);
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);

            // Draw "Slip Plane" guides in Pure mode
            if (mode === 'pure' && activeLayer) {
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.2)';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, activeLayer.baseY - ROW_HEIGHT/2);
                ctx.lineTo(width, activeLayer.baseY - ROW_HEIGHT/2);
                ctx.moveTo(0, activeLayer.baseY + ROW_HEIGHT/2);
                ctx.lineTo(width, activeLayer.baseY + ROW_HEIGHT/2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            layers.forEach(l => {
                l.update();
                l.draw();
            });

            requestAnimationFrame(animate);
        }

        // Mouse handling
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            layers.forEach(l => {
                if (Math.abs(mouseY - l.baseY) < ROW_HEIGHT/2) {
                    activeLayer = l;
                    dragStartX = mouseX;
                    startOffsetX = l.targetX;
                }
            });
        });

        window.addEventListener('mousemove', (e) => {
            if (!activeLayer) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            
            let moveAmount = mouseX - dragStartX;

            if (mode === 'alloy') {
                // Apply "Lattice Friction"
                // The layer struggles to move past the distorted regions
                const resistance = 0.3;
                moveAmount *= resistance;
                
                // Visual feedback for struggle
                feedback.style.opacity = "1";
            } else {
                feedback.style.opacity = "0";
            }

            activeLayer.targetX = startOffsetX + moveAmount;
        });

        window.addEventListener('mouseup', () => { 
            activeLayer = null; 
            feedback.style.opacity = "0";
        });

        // Responsive
        window.addEventListener('resize', () => {
            width = canvas.parentElement.clientWidth;
            height = canvas.parentElement.clientHeight;
            canvas.width = width;
            canvas.height = height;
            initLattice();
        });

        window.onload = () => {
            window.dispatchEvent(new Event('resize'));
            animate();
        };

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            const t = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const mouseX = t.clientX - rect.left;
            const mouseY = t.clientY - rect.top;
            layers.forEach(l => {
                if (Math.abs(mouseY - l.baseY) < ROW_HEIGHT/2) {
                    activeLayer = l;
                    dragStartX = mouseX;
                    startOffsetX = l.targetX;
                }
            });
        }, {passive: false});

        canvas.addEventListener('touchmove', (e) => {
            if (!activeLayer) return;
            e.preventDefault();
            const t = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const mouseX = t.clientX - rect.left;
            let moveAmount = mouseX - dragStartX;
            if (mode === 'alloy') moveAmount *= 0.3;
            activeLayer.targetX = startOffsetX + moveAmount;
        }, {passive: false});

        window.addEventListener('touchend', () => activeLayer = null);

    </script>
</body>
</html>